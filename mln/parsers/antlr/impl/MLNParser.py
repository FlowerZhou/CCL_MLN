# Generated from MLN.g4 by ANTLR 4.8
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\24")
        buf.write("\u00ac\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\3\2\3\2")
        buf.write("\3\2\3\2\3\3\7\3*\n\3\f\3\16\3-\13\3\3\4\5\4\60\n\4\3")
        buf.write("\4\3\4\3\4\3\4\3\4\7\4\67\n\4\f\4\16\4:\13\4\3\4\3\4\3")
        buf.write("\5\3\5\5\5@\n\5\3\5\5\5C\n\5\3\6\7\6F\n\6\f\6\16\6I\13")
        buf.write("\6\3\7\3\7\5\7M\n\7\3\b\5\bP\n\b\3\b\3\b\3\b\5\bU\n\b")
        buf.write("\3\b\3\b\3\b\5\bZ\n\b\3\t\3\t\3\t\3\n\5\n`\n\n\3\n\3\n")
        buf.write("\3\n\7\ne\n\n\f\n\16\nh\13\n\3\n\3\n\5\nl\n\n\3\n\3\n")
        buf.write("\3\n\7\nq\n\n\f\n\16\nt\13\n\3\13\3\13\3\13\3\13\7\13")
        buf.write("z\n\13\f\13\16\13}\13\13\3\f\5\f\u0080\n\f\3\f\3\f\3\r")
        buf.write("\3\r\5\r\u0086\n\r\3\16\3\16\3\16\3\16\3\16\7\16\u008d")
        buf.write("\n\16\f\16\16\16\u0090\13\16\3\16\3\16\3\17\6\17\u0095")
        buf.write("\n\17\r\17\16\17\u0096\3\17\3\17\3\20\3\20\3\21\6\21\u009e")
        buf.write("\n\21\r\21\16\21\u009f\3\21\3\21\3\22\5\22\u00a5\n\22")
        buf.write("\3\22\5\22\u00a8\n\22\3\22\3\22\3\22\2\2\23\2\4\6\b\n")
        buf.write("\f\16\20\22\24\26\30\32\34\36 \"\2\4\3\2\13\f\3\2\22\23")
        buf.write("\2\u00b0\2$\3\2\2\2\4+\3\2\2\2\6/\3\2\2\2\b=\3\2\2\2\n")
        buf.write("G\3\2\2\2\fL\3\2\2\2\16Y\3\2\2\2\20[\3\2\2\2\22_\3\2\2")
        buf.write("\2\24u\3\2\2\2\26\177\3\2\2\2\30\u0085\3\2\2\2\32\u0087")
        buf.write("\3\2\2\2\34\u0094\3\2\2\2\36\u009a\3\2\2\2 \u009d\3\2")
        buf.write("\2\2\"\u00a4\3\2\2\2$%\5\4\3\2%&\5\n\6\2&\'\7\2\2\3\'")
        buf.write("\3\3\2\2\2(*\5\6\4\2)(\3\2\2\2*-\3\2\2\2+)\3\2\2\2+,\3")
        buf.write("\2\2\2,\5\3\2\2\2-+\3\2\2\2.\60\7\16\2\2/.\3\2\2\2/\60")
        buf.write("\3\2\2\2\60\61\3\2\2\2\61\62\7\24\2\2\62\63\7\3\2\2\63")
        buf.write("8\5\b\5\2\64\65\7\4\2\2\65\67\5\b\5\2\66\64\3\2\2\2\67")
        buf.write(":\3\2\2\28\66\3\2\2\289\3\2\2\29;\3\2\2\2:8\3\2\2\2;<")
        buf.write("\7\5\2\2<\7\3\2\2\2=?\7\24\2\2>@\7\24\2\2?>\3\2\2\2?@")
        buf.write("\3\2\2\2@B\3\2\2\2AC\7\13\2\2BA\3\2\2\2BC\3\2\2\2C\t\3")
        buf.write("\2\2\2DF\5\f\7\2ED\3\2\2\2FI\3\2\2\2GE\3\2\2\2GH\3\2\2")
        buf.write("\2H\13\3\2\2\2IG\3\2\2\2JM\5\16\b\2KM\5\20\t\2LJ\3\2\2")
        buf.write("\2LK\3\2\2\2M\r\3\2\2\2NP\7\6\2\2ON\3\2\2\2OP\3\2\2\2")
        buf.write("PQ\3\2\2\2QR\7\23\2\2RZ\5\22\n\2SU\7\6\2\2TS\3\2\2\2T")
        buf.write("U\3\2\2\2UV\3\2\2\2VW\7\24\2\2WX\7\7\2\2XZ\5\22\n\2YO")
        buf.write("\3\2\2\2YT\3\2\2\2Z\17\3\2\2\2[\\\5\22\n\2\\]\7\17\2\2")
        buf.write("]\21\3\2\2\2^`\5\24\13\2_^\3\2\2\2_`\3\2\2\2`k\3\2\2\2")
        buf.write("af\5\26\f\2bc\7\4\2\2ce\5\26\f\2db\3\2\2\2eh\3\2\2\2f")
        buf.write("d\3\2\2\2fg\3\2\2\2gi\3\2\2\2hf\3\2\2\2ij\7\21\2\2jl\3")
        buf.write("\2\2\2ka\3\2\2\2kl\3\2\2\2lm\3\2\2\2mr\5\26\f\2no\7\b")
        buf.write("\2\2oq\5\26\f\2pn\3\2\2\2qt\3\2\2\2rp\3\2\2\2rs\3\2\2")
        buf.write("\2s\23\3\2\2\2tr\3\2\2\2uv\7\20\2\2v{\7\24\2\2wx\7\4\2")
        buf.write("\2xz\7\24\2\2yw\3\2\2\2z}\3\2\2\2{y\3\2\2\2{|\3\2\2\2")
        buf.write("|\25\3\2\2\2}{\3\2\2\2~\u0080\t\2\2\2\177~\3\2\2\2\177")
        buf.write("\u0080\3\2\2\2\u0080\u0081\3\2\2\2\u0081\u0082\5\32\16")
        buf.write("\2\u0082\27\3\2\2\2\u0083\u0086\7\24\2\2\u0084\u0086\t")
        buf.write("\3\2\2\u0085\u0083\3\2\2\2\u0085\u0084\3\2\2\2\u0086\31")
        buf.write("\3\2\2\2\u0087\u0088\7\24\2\2\u0088\u0089\7\3\2\2\u0089")
        buf.write("\u008e\5\30\r\2\u008a\u008b\7\4\2\2\u008b\u008d\5\30\r")
        buf.write("\2\u008c\u008a\3\2\2\2\u008d\u0090\3\2\2\2\u008e\u008c")
        buf.write("\3\2\2\2\u008e\u008f\3\2\2\2\u008f\u0091\3\2\2\2\u0090")
        buf.write("\u008e\3\2\2\2\u0091\u0092\7\5\2\2\u0092\33\3\2\2\2\u0093")
        buf.write("\u0095\5\36\20\2\u0094\u0093\3\2\2\2\u0095\u0096\3\2\2")
        buf.write("\2\u0096\u0094\3\2\2\2\u0096\u0097\3\2\2\2\u0097\u0098")
        buf.write("\3\2\2\2\u0098\u0099\7\2\2\3\u0099\35\3\2\2\2\u009a\u009b")
        buf.write("\5\32\16\2\u009b\37\3\2\2\2\u009c\u009e\5\"\22\2\u009d")
        buf.write("\u009c\3\2\2\2\u009e\u009f\3\2\2\2\u009f\u009d\3\2\2\2")
        buf.write("\u009f\u00a0\3\2\2\2\u00a0\u00a1\3\2\2\2\u00a1\u00a2\7")
        buf.write("\2\2\3\u00a2!\3\2\2\2\u00a3\u00a5\7\23\2\2\u00a4\u00a3")
        buf.write("\3\2\2\2\u00a4\u00a5\3\2\2\2\u00a5\u00a7\3\2\2\2\u00a6")
        buf.write("\u00a8\7\13\2\2\u00a7\u00a6\3\2\2\2\u00a7\u00a8\3\2\2")
        buf.write("\2\u00a8\u00a9\3\2\2\2\u00a9\u00aa\5\32\16\2\u00aa#\3")
        buf.write("\2\2\2\30+/8?BGLOTY_fkr{\177\u0085\u008e\u0096\u009f\u00a4")
        buf.write("\u00a7")
        return buf.getvalue()


class MLNParser ( Parser ):

    grammarFileName = "MLN.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'('", "','", "')'", "'@'", "':'", "'v'", 
                     "<INVALID>", "<INVALID>", "'!'", "'+'", "'-'", "'*'", 
                     "'.'", "<INVALID>", "'=>'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "WS", "COMMENT", 
                      "NOT", "PLUS", "MINUS", "ASTERISK", "PERIOD", "EXIST", 
                      "IMPLIES", "STRING", "NUMBER", "ID" ]

    RULE_definitions = 0
    RULE_schemaList = 1
    RULE_schema = 2
    RULE_predArg = 3
    RULE_ruleList = 4
    RULE_mlnRule = 5
    RULE_softRule = 6
    RULE_hardRule = 7
    RULE_foclause = 8
    RULE_existQuan = 9
    RULE_literal = 10
    RULE_term = 11
    RULE_atom = 12
    RULE_queryList = 13
    RULE_query = 14
    RULE_evidenceList = 15
    RULE_evidence = 16

    ruleNames =  [ "definitions", "schemaList", "schema", "predArg", "ruleList", 
                   "mlnRule", "softRule", "hardRule", "foclause", "existQuan", 
                   "literal", "term", "atom", "queryList", "query", "evidenceList", 
                   "evidence" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    WS=7
    COMMENT=8
    NOT=9
    PLUS=10
    MINUS=11
    ASTERISK=12
    PERIOD=13
    EXIST=14
    IMPLIES=15
    STRING=16
    NUMBER=17
    ID=18

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.8")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class DefinitionsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def schemaList(self):
            return self.getTypedRuleContext(MLNParser.SchemaListContext,0)


        def ruleList(self):
            return self.getTypedRuleContext(MLNParser.RuleListContext,0)


        def EOF(self):
            return self.getToken(MLNParser.EOF, 0)

        def getRuleIndex(self):
            return MLNParser.RULE_definitions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefinitions" ):
                listener.enterDefinitions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefinitions" ):
                listener.exitDefinitions(self)




    def definitions(self):

        localctx = MLNParser.DefinitionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_definitions)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 34
            self.schemaList()
            self.state = 35
            self.ruleList()
            self.state = 36
            self.match(MLNParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SchemaListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def schema(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MLNParser.SchemaContext)
            else:
                return self.getTypedRuleContext(MLNParser.SchemaContext,i)


        def getRuleIndex(self):
            return MLNParser.RULE_schemaList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSchemaList" ):
                listener.enterSchemaList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSchemaList" ):
                listener.exitSchemaList(self)




    def schemaList(self):

        localctx = MLNParser.SchemaListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_schemaList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 41
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,0,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 38
                    self.schema() 
                self.state = 43
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,0,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SchemaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.a1 = None # Token
            self.pname = None # Token
            self._predArg = None # PredArgContext
            self.types = list() # of PredArgContexts

        def ID(self):
            return self.getToken(MLNParser.ID, 0)

        def predArg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MLNParser.PredArgContext)
            else:
                return self.getTypedRuleContext(MLNParser.PredArgContext,i)


        def ASTERISK(self):
            return self.getToken(MLNParser.ASTERISK, 0)

        def getRuleIndex(self):
            return MLNParser.RULE_schema

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSchema" ):
                listener.enterSchema(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSchema" ):
                listener.exitSchema(self)




    def schema(self):

        localctx = MLNParser.SchemaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_schema)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 45
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==MLNParser.ASTERISK:
                self.state = 44
                localctx.a1 = self.match(MLNParser.ASTERISK)


            self.state = 47
            localctx.pname = self.match(MLNParser.ID)
            self.state = 48
            self.match(MLNParser.T__0)
            self.state = 49
            localctx._predArg = self.predArg()
            localctx.types.append(localctx._predArg)
            self.state = 54
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==MLNParser.T__1:
                self.state = 50
                self.match(MLNParser.T__1)
                self.state = 51
                localctx._predArg = self.predArg()
                localctx.types.append(localctx._predArg)
                self.state = 56
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 57
            self.match(MLNParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredArgContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None # Token
            self.name = None # Token
            self.uni = None # Token

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(MLNParser.ID)
            else:
                return self.getToken(MLNParser.ID, i)

        def NOT(self):
            return self.getToken(MLNParser.NOT, 0)

        def getRuleIndex(self):
            return MLNParser.RULE_predArg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredArg" ):
                listener.enterPredArg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredArg" ):
                listener.exitPredArg(self)




    def predArg(self):

        localctx = MLNParser.PredArgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_predArg)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 59
            localctx.type_ = self.match(MLNParser.ID)
            self.state = 61
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==MLNParser.ID:
                self.state = 60
                localctx.name = self.match(MLNParser.ID)


            self.state = 64
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==MLNParser.NOT:
                self.state = 63
                localctx.uni = self.match(MLNParser.NOT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def mlnRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MLNParser.MlnRuleContext)
            else:
                return self.getTypedRuleContext(MLNParser.MlnRuleContext,i)


        def getRuleIndex(self):
            return MLNParser.RULE_ruleList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleList" ):
                listener.enterRuleList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleList" ):
                listener.exitRuleList(self)




    def ruleList(self):

        localctx = MLNParser.RuleListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_ruleList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 69
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << MLNParser.T__3) | (1 << MLNParser.NOT) | (1 << MLNParser.PLUS) | (1 << MLNParser.EXIST) | (1 << MLNParser.NUMBER) | (1 << MLNParser.ID))) != 0):
                self.state = 66
                self.mlnRule()
                self.state = 71
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MlnRuleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def softRule(self):
            return self.getTypedRuleContext(MLNParser.SoftRuleContext,0)


        def hardRule(self):
            return self.getTypedRuleContext(MLNParser.HardRuleContext,0)


        def getRuleIndex(self):
            return MLNParser.RULE_mlnRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMlnRule" ):
                listener.enterMlnRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMlnRule" ):
                listener.exitMlnRule(self)




    def mlnRule(self):

        localctx = MLNParser.MlnRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_mlnRule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 74
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                self.state = 72
                self.softRule()
                pass

            elif la_ == 2:
                self.state = 73
                self.hardRule()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SoftRuleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.du = None # Token
            self.weight = None # Token
            self.fc = None # FoclauseContext
            self.warg = None # Token

        def NUMBER(self):
            return self.getToken(MLNParser.NUMBER, 0)

        def foclause(self):
            return self.getTypedRuleContext(MLNParser.FoclauseContext,0)


        def ID(self):
            return self.getToken(MLNParser.ID, 0)

        def getRuleIndex(self):
            return MLNParser.RULE_softRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSoftRule" ):
                listener.enterSoftRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSoftRule" ):
                listener.exitSoftRule(self)




    def softRule(self):

        localctx = MLNParser.SoftRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_softRule)
        self._la = 0 # Token type
        try:
            self.state = 87
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 77
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==MLNParser.T__3:
                    self.state = 76
                    localctx.du = self.match(MLNParser.T__3)


                self.state = 79
                localctx.weight = self.match(MLNParser.NUMBER)
                self.state = 80
                localctx.fc = self.foclause()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 82
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==MLNParser.T__3:
                    self.state = 81
                    localctx.du = self.match(MLNParser.T__3)


                self.state = 84
                localctx.warg = self.match(MLNParser.ID)
                self.state = 85
                self.match(MLNParser.T__4)
                self.state = 86
                localctx.fc = self.foclause()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HardRuleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.fc = None # FoclauseContext

        def PERIOD(self):
            return self.getToken(MLNParser.PERIOD, 0)

        def foclause(self):
            return self.getTypedRuleContext(MLNParser.FoclauseContext,0)


        def getRuleIndex(self):
            return MLNParser.RULE_hardRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHardRule" ):
                listener.enterHardRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHardRule" ):
                listener.exitHardRule(self)




    def hardRule(self):

        localctx = MLNParser.HardRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_hardRule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 89
            localctx.fc = self.foclause()
            self.state = 90
            self.match(MLNParser.PERIOD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FoclauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.exq = None # ExistQuanContext
            self._literal = None # LiteralContext
            self.ants = list() # of LiteralContexts
            self.lits = list() # of LiteralContexts

        def literal(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MLNParser.LiteralContext)
            else:
                return self.getTypedRuleContext(MLNParser.LiteralContext,i)


        def IMPLIES(self):
            return self.getToken(MLNParser.IMPLIES, 0)

        def existQuan(self):
            return self.getTypedRuleContext(MLNParser.ExistQuanContext,0)


        def getRuleIndex(self):
            return MLNParser.RULE_foclause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFoclause" ):
                listener.enterFoclause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFoclause" ):
                listener.exitFoclause(self)




    def foclause(self):

        localctx = MLNParser.FoclauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_foclause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 93
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==MLNParser.EXIST:
                self.state = 92
                localctx.exq = self.existQuan()


            self.state = 105
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.state = 95
                localctx._literal = self.literal()
                localctx.ants.append(localctx._literal)
                self.state = 100
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==MLNParser.T__1:
                    self.state = 96
                    self.match(MLNParser.T__1)
                    self.state = 97
                    localctx._literal = self.literal()
                    localctx.ants.append(localctx._literal)
                    self.state = 102
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 103
                self.match(MLNParser.IMPLIES)


            self.state = 107
            localctx._literal = self.literal()
            localctx.lits.append(localctx._literal)
            self.state = 112
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==MLNParser.T__5:
                self.state = 108
                self.match(MLNParser.T__5)
                self.state = 109
                localctx._literal = self.literal()
                localctx.lits.append(localctx._literal)
                self.state = 114
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExistQuanContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._ID = None # Token
            self.vs = list() # of Tokens

        def EXIST(self):
            return self.getToken(MLNParser.EXIST, 0)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(MLNParser.ID)
            else:
                return self.getToken(MLNParser.ID, i)

        def getRuleIndex(self):
            return MLNParser.RULE_existQuan

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExistQuan" ):
                listener.enterExistQuan(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExistQuan" ):
                listener.exitExistQuan(self)




    def existQuan(self):

        localctx = MLNParser.ExistQuanContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_existQuan)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 115
            self.match(MLNParser.EXIST)
            self.state = 116
            localctx._ID = self.match(MLNParser.ID)
            localctx.vs.append(localctx._ID)
            self.state = 121
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==MLNParser.T__1:
                self.state = 117
                self.match(MLNParser.T__1)
                self.state = 118
                localctx._ID = self.match(MLNParser.ID)
                localctx.vs.append(localctx._ID)
                self.state = 123
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.pref = None # Token
            self.a = None # AtomContext

        def atom(self):
            return self.getTypedRuleContext(MLNParser.AtomContext,0)


        def PLUS(self):
            return self.getToken(MLNParser.PLUS, 0)

        def NOT(self):
            return self.getToken(MLNParser.NOT, 0)

        def getRuleIndex(self):
            return MLNParser.RULE_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral" ):
                listener.enterLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral" ):
                listener.exitLiteral(self)




    def literal(self):

        localctx = MLNParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_literal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 125
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==MLNParser.NOT or _la==MLNParser.PLUS:
                self.state = 124
                localctx.pref = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==MLNParser.NOT or _la==MLNParser.PLUS):
                    localctx.pref = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 127
            localctx.a = self.atom()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TermContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.x = None # Token
            self.d = None # Token

        def ID(self):
            return self.getToken(MLNParser.ID, 0)

        def NUMBER(self):
            return self.getToken(MLNParser.NUMBER, 0)

        def STRING(self):
            return self.getToken(MLNParser.STRING, 0)

        def getRuleIndex(self):
            return MLNParser.RULE_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm" ):
                listener.enterTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm" ):
                listener.exitTerm(self)




    def term(self):

        localctx = MLNParser.TermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_term)
        self._la = 0 # Token type
        try:
            self.state = 131
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [MLNParser.ID]:
                self.enterOuterAlt(localctx, 1)
                self.state = 129
                localctx.x = self.match(MLNParser.ID)
                pass
            elif token in [MLNParser.STRING, MLNParser.NUMBER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 130
                localctx.d = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==MLNParser.STRING or _la==MLNParser.NUMBER):
                    localctx.d = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AtomContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.pred = None # Token
            self._term = None # TermContext
            self.terms = list() # of TermContexts

        def ID(self):
            return self.getToken(MLNParser.ID, 0)

        def term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MLNParser.TermContext)
            else:
                return self.getTypedRuleContext(MLNParser.TermContext,i)


        def getRuleIndex(self):
            return MLNParser.RULE_atom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom" ):
                listener.enterAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom" ):
                listener.exitAtom(self)




    def atom(self):

        localctx = MLNParser.AtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_atom)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 133
            localctx.pred = self.match(MLNParser.ID)
            self.state = 134
            self.match(MLNParser.T__0)
            self.state = 135
            localctx._term = self.term()
            localctx.terms.append(localctx._term)
            self.state = 140
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==MLNParser.T__1:
                self.state = 136
                self.match(MLNParser.T__1)
                self.state = 137
                localctx._term = self.term()
                localctx.terms.append(localctx._term)
                self.state = 142
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 143
            self.match(MLNParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(MLNParser.EOF, 0)

        def query(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MLNParser.QueryContext)
            else:
                return self.getTypedRuleContext(MLNParser.QueryContext,i)


        def getRuleIndex(self):
            return MLNParser.RULE_queryList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQueryList" ):
                listener.enterQueryList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQueryList" ):
                listener.exitQueryList(self)




    def queryList(self):

        localctx = MLNParser.QueryListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_queryList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 146 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 145
                self.query()
                self.state = 148 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==MLNParser.ID):
                    break

            self.state = 150
            self.match(MLNParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.a = None # AtomContext

        def atom(self):
            return self.getTypedRuleContext(MLNParser.AtomContext,0)


        def getRuleIndex(self):
            return MLNParser.RULE_query

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuery" ):
                listener.enterQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuery" ):
                listener.exitQuery(self)




    def query(self):

        localctx = MLNParser.QueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_query)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 152
            localctx.a = self.atom()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EvidenceListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(MLNParser.EOF, 0)

        def evidence(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MLNParser.EvidenceContext)
            else:
                return self.getTypedRuleContext(MLNParser.EvidenceContext,i)


        def getRuleIndex(self):
            return MLNParser.RULE_evidenceList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEvidenceList" ):
                listener.enterEvidenceList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEvidenceList" ):
                listener.exitEvidenceList(self)




    def evidenceList(self):

        localctx = MLNParser.EvidenceListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_evidenceList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 155 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 154
                self.evidence()
                self.state = 157 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << MLNParser.NOT) | (1 << MLNParser.NUMBER) | (1 << MLNParser.ID))) != 0)):
                    break

            self.state = 159
            self.match(MLNParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EvidenceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.prior = None # Token
            self.perf = None # Token
            self.a = None # AtomContext

        def atom(self):
            return self.getTypedRuleContext(MLNParser.AtomContext,0)


        def NUMBER(self):
            return self.getToken(MLNParser.NUMBER, 0)

        def NOT(self):
            return self.getToken(MLNParser.NOT, 0)

        def getRuleIndex(self):
            return MLNParser.RULE_evidence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEvidence" ):
                listener.enterEvidence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEvidence" ):
                listener.exitEvidence(self)




    def evidence(self):

        localctx = MLNParser.EvidenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_evidence)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 162
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==MLNParser.NUMBER:
                self.state = 161
                localctx.prior = self.match(MLNParser.NUMBER)


            self.state = 165
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==MLNParser.NOT:
                self.state = 164
                localctx.perf = self.match(MLNParser.NOT)


            self.state = 167
            localctx.a = self.atom()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





